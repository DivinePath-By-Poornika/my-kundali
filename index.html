<!DOCTYPE html>
<html lang="hi">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Standalone Modern Kundli Generator</title>
<style>
  @import url('https://fonts.googleapis.com/css2?family=Poppins:wght@300;600&display=swap');
  body {
    margin: 0; background: linear-gradient(135deg, #222831, #393e46);
    font-family: 'Poppins', sans-serif; color: #eeeeee;
    display: flex; flex-direction: column; align-items: center; min-height: 100vh;
    padding: 20px;
  }
  header {
    text-align: center; margin-bottom: 20px;
  }
  header h1 {
    margin: 0; font-weight: 600; font-size: 2.5rem;
  }
  form {
    background: #00adb5;
    padding: 20px 25px;
    border-radius: 12px;
    width: 100%;
    max-width: 480px;
    box-shadow: 0 4px 20px #00adb550;
  }
  label {
    font-weight: 600;
  }
  input, select, button {
    width: 100%; padding: 10px 12px; margin-top: 6px; margin-bottom: 17px;
    border-radius: 8px; border: none; font-size: 1rem;
    font-family: 'Poppins', sans-serif;
    transition: background-color 0.3s ease, box-shadow 0.3s ease;
  }
  input:focus, select:focus {
    outline: none;
    box-shadow: 0 0 8px #fff;
    background-color: #68fff8;
    color: #222831;
  }
  button {
    cursor: pointer;
    background: linear-gradient(45deg, #ff2e63, #ff764a);
    color: #fff;
    font-weight: 700;
    font-size: 1.2rem;
    box-shadow: 0 0 10px #ff4747;
    border: none;
  }
  button:hover {
    box-shadow: 0 0 20px #ff7676;
  }

  main {
    margin-top: 30px; width: 100%; max-width: 900px;
  }
  #chart-container {
    margin-top: 30px;
    background: #393e46;
    border-radius: 20px;
    padding: 30px;
    box-shadow: 0 0 30px #00adb5aa;
    position: relative;
  }
  svg {
    width: 100%; height: auto;
  }
  .house-label {
    fill: #00fff7;
    font-weight: 700;
    font-size: 16px;
    user-select: none;
  }
  .planet-text {
    fill: #ff467e;
    font-weight: 700;
    font-size: 14px;
    text-shadow: 0 0 3px #ff467eaa;
    pointer-events: none;
  }

  /* Animation for planets */
  .planet-circle {
    transition: transform 1.25s cubic-bezier(0.68, -0.55, 0.27, 1.55);
    transform-origin: center;
    cursor: pointer;
    fill: #ff477e;
    stroke: #fff;
    stroke-width: 1.5px;
    filter: drop-shadow(0 0 3px #ff477ecc);
  }
  .planet-circle:hover {
    fill: #ffffff;
    filter: drop-shadow(0 0 10px #ff7676);
  }

  #analysis {
    margin-top: 20px;
    background: #222831;
    padding: 20px;
    border-radius: 14px;
    font-size: 1rem;
    line-height: 1.4;
    white-space: pre-line;
    color: #e0e0e0;
    max-height: 400px;
    overflow-y: auto;
    box-shadow: 0 0 12px #00adb5;
  }

  /* Responsive */
  @media(max-width: 600px) {
    form {
      max-width: 100%;
    }
    #chart-container {
      padding: 20px;
    }
  }
</style>
</head>
<body>
<header>
  <h1>Standalone Modern Kundli Generator</h1>
  <p style="color:#00fff7; font-weight:500;">Date, Time, & Latitude/Longitude daal kar apna accurate Kundli hasil karein</p>
</header>

<form id="kundliForm" onsubmit="return false;">
  <label for="dob">Date of Birth</label>
  <input type="date" id="dob" required autocomplete="off" />

  <label for="tob">Time of Birth (24h format, local time)</label>
  <input type="time" id="tob" required step="60" value="12:00" />

  <label for="lat">Latitude (e.g. 28.6139 for New Delhi)</label>
  <input type="number" id="lat" step="0.0001" placeholder="Latitude" required />

  <label for="lng">Longitude (e.g. 77.2090 for New Delhi)</label>
  <input type="number" id="lng" step="0.0001" placeholder="Longitude" required />

  <button id="btnGenerate">Generate Kundli & Chart</button>
</form>

<main>
  <section id="chart-container" aria-label="Kundli Chart">
    <!-- SVG kundli chart will be drawn here dynamically -->
  </section>

  <section id="analysis" aria-live="polite" role="region" aria-label="Detailed Kundli Analysis">
    Kundli generate karne ke liye upar details doldijiye.
  </section>
</main>

<script>
  // Astronomy/math utilities for planet position calculation
  // NOTE: This simplified approach uses approximation formulas for planet longitudes
  // based on mean elements and Keplerian orbits around J2000.
  // For production, use Swiss Ephemeris or NASA data if possible.

  class Astronomy {
    // Convert date-time (local) + timezone offset to Julian Day UT
    static toJulianDay(year, month, day, hour, min, sec=0) {
      if (month <= 2) {
        year -=1; month += 12;
      }
      const A = Math.floor(year/100);
      const B = 2 - A + Math.floor(A/4);
      const dayFraction = (hour + min/60 + sec/3600)/24;
      const JD = Math.floor(365.25*(year+4716)) + Math.floor(30.6001*(month+1)) + day + dayFraction + B - 1524.5;
      return JD;
    }

    // Calculate Sun's apparent longitude at Julian Day (approx)
    static sunLongitude(JD) {
      const n = JD - 2451545.0; // days since J2000.0
      const L = (280.460 + 0.9856474 * n) % 360;
      const g = (357.528 + 0.9856003 * n) % 360;
      const gRad = Astronomy.degToRad(g);
      const lambda = L + 1.915 * Math.sin(gRad) + 0.020 * Math.sin(2 * gRad);
      return (lambda + 360) % 360;
    }

    // Calculate Moon's longitude approx from JD (simplified)
    static moonLongitude(JD) {
      const n = JD - 2451550.1;
      const L = (218.316 + 13.176396 * n) % 360;
      const M = (134.963 + 13.064993 * n) % 360;
      const F = (93.272 + 13.229350 * n) % 360;
      const LRad = Astronomy.degToRad(L);
      const MRad = Astronomy.degToRad(M);
      const FRad = Astronomy.degToRad(F);
      const lambda =
        L +
        6.289 * Math.sin(MRad) -
        3.0 * Math.sin(LRad - Astronomy.degToRad(297.850)) +
        1.274 * Math.sin(2 * Astronomy.degToRad(L) - MRad) +
        0.658 * Math.sin(2 * LRad) +
        0.214 * Math.sin(2 * MRad) -
        0.186 * Math.sin(Astronomy.degToRad(297.850)) +
        0.114 * Math.sin(2 * FRad);
      return (lambda + 360) % 360;
    }

    // Mercury approx longitude (using simplified formula)
    static mercuryLongitude(JD) {
      const n = JD - 2451545.0;
      const L = (252.25084 + 4.0923344368 * n) % 360;
      return (L + 360) % 360;
    }

    // Venus approx longitude
    static venusLongitude(JD) {
      const n = JD - 2451545.0;
      const L = (181.9798 + 1.6021302244 * n) % 360;
      return (L + 360) % 360;
    }

    // Mars approx longitude
    static marsLongitude(JD) {
      const n = JD - 2451545.0;
      const L = (355.433 + 0.5240207766 * n) % 360;
      return (L + 360) % 360;
    }

    // Jupiter approx longitude
    static jupiterLongitude(JD) {
      const n = JD - 2451545.0;
      const L = (34.3515 + 0.083091 * n) % 360;
      return (L + 360) % 360;
    }

    // Saturn approx longitude
    static saturnLongitude(JD) {
      const n = JD - 2451545.0;
      const L = (50.07745 + 0.0300657 * n) % 360;
      return (L + 360) % 360;
    }

    static degToRad(d) { return d * (Math.PI / 180); }
    static radToDeg(r) { return r * (180 / Math.PI); }

    // Calculate ascendant approximate (simplified) from JD and latitude
    static ascendantLongitude(JD, latitude) {
      // Very approximate: use sidereal time and ecliptic obliquity.
      // This can be improved with Swiss Ephemeris or advanced astronomy libs.
      const T = (JD - 2451545.0) / 36525.0; // Julian centuries
      const obliquity = 23.4393 - 0.01300 * T; // ecliptic obliquity approx in deg

      // Calculate sidereal time at Greenwich at 0 UT (LST0)
      const GST = (280.46061837 + 360.98564736629 * (JD - 2451545.0) + 
                  T*T*(0.000387933 - T/38710000.0)) % 360;

      const LST = (GST + longitude) % 360;

      // Latitude in radians
      const latRad = Astronomy.degToRad(latitude);
      const oblRad = Astronomy.degToRad(obliquity);
      const LSTRad = Astronomy.degToRad(LST);

      // Eqn for Ascendant longitude in ecliptic coordinate
      const tanAsc = (Math.cos(LSTRad)) / (Math.sin(LSTRad) * Math.cos(oblRad) - Math.tan(latRad) * Math.sin(oblRad));
      let asc = Math.atan(tanAsc);
      asc = Astronomy.radToDeg(asc);
      if (LSTRad > Math.PI) asc += 180;
      if (asc < 0) asc += 360;
      return asc % 360;
    }
  }

  // Sign names and abbreviations for display
  const signs = ["मेष", "वृषभ", "मिथुन", "कर्क", "सिंह", "कन्या", "तुला", "वृश्चिक", "धनु", "मकर", "कुम्भ", "मीन"];

  // Convert planet longitude to sign and degree in sign
  function formatLongitude(lon) {
    const signIndex = Math.floor(lon / 30);
    const signDegree = lon % 30;
    return `${signDegree.toFixed(2)}° ${signs[signIndex]}`;
  }

  // Draw North Indian style Kundli chart in SVG
  function drawKundliChart(planets, ascendant, container) {
    const width = Math.min(700, window.innerWidth - 40);
    const height = width;
    container.innerHTML = "";

    // Create SVG element
    const svgNS = "http://www.w3.org/2000/svg";
    const svg = document.createElementNS(svgNS, "svg");
    svg.setAttribute("width", width);
    svg.setAttribute("height", height);
    svg.setAttribute("viewBox", `0 0 600 600`);
    container.appendChild(svg);

    // Draw diamond outer frame & house boundaries - North Indian style
    const diamondPoints = "300,20 580,300 300,580 20,300";
    const diamond = document.createElementNS(svgNS, "polygon");
    diamond.setAttribute("points", diamondPoints);
    diamond.setAttribute("stroke", "#00fff7");
    diamond.setAttribute("stroke-width", "5");
    diamond.setAttribute("fill", "none");
    diamond.setAttribute("filter", "drop-shadow(0 0 4px #00fff7aa)");
    svg.appendChild(diamond);

    // Draw intersecting lines dividing houses
    const lines = [
      ["20", "300", "300", "580"],
      ["300", "580", "580", "300"],
      ["580", "300", "300", "20"],
      ["300", "20", "20", "300"]
    ];
    lines.forEach(([x1, y1, x2, y2]) => {
      const line = document.createElementNS(svgNS, "line");
      line.setAttribute("x1", x1);
      line.setAttribute("y1", y1);
      line.setAttribute("x2", x2);
      line.setAttribute("y2", y2);
      line.setAttribute("stroke", "#00fff7");
      line.setAttribute("stroke-width", "3");
      svg.appendChild(line);
    });

    // House centers & labels for North Indian style
    const houseCenters = [
      [300, 125], [420, 195], [455, 335], [420, 465],
      [300, 525], [180, 460], [145, 325], [180, 190],
      [300, 300], [360, 230], [300, 180], [240, 230]
    ];

    // Place house numbers 1 to 12 clockwise starting from Ascendant house
    // Ascendant house index calculation (belongs where ascendant degree lies)
    const ascSignIndex = Math.floor(ascendant / 30);
    // Houses are 1 to 12, Asc = house 1; so house n = (ascSignIndex + n - 1) mod 12

    // Put house numbers clockwise based on Asc
    for (let i = 1; i <= 12; i++) {
      const houseNumber = (((i - 1) + ascSignIndex) % 12) + 1;
      const [cx, cy] = houseCenters[i - 1];
      const text = document.createElementNS(svgNS, "text");
      text.setAttribute("x", cx);
      text.setAttribute("y", cy - 20);
      text.setAttribute("class", "house-label");
      text.setAttribute("text-anchor", "middle");
      text.textContent = houseNumber;
      svg.appendChild(text);
    }

    // Calculate planet house positions based on their longitude and ascendant
    // Place planets near their position on circle inside chart

    // Radius to place planet circles from center
    const cx = 300;
    const cy = 300;
    const r = 230;

    // For each planet, calculate angle relative to ascendant and position in circle
    planets.forEach(p => {
      const lon = p.longitude;
      // Relative angle (degrees) from ascendant (start angle to Aries = 0)
      let relAngle = (lon - ascendant + 360) % 360;
      // Convert to radians and invert y (because SVG y+ downward)
      const angleRad = (relAngle - 90) * Math.PI / 180;

      // Calculate planet position on circle
      const px = cx + r * Math.cos(angleRad);
      const py = cy + r * Math.sin(angleRad);

      // Draw circle for planet
      const circle = document.createElementNS(svgNS, "circle");
      circle.setAttribute("cx", px);
      circle.setAttribute("cy", py);
      circle.setAttribute("r", 20);
      circle.setAttribute("class", "planet-circle");
      circle.title = `${p.name}: ${formatLongitude(lon)}`;

      // Animation with tween on new positions
      circle.style.transform = "scale(0)";
      setTimeout(() => circle.style.transform = "scale(1)", 100);

      svg.appendChild(circle);

      // Planet label text below circle
      const text = document.createElementNS(svgNS, "text");
      text.setAttribute("x", px);
      text.setAttribute("y", py + 38);
      text.setAttribute("class", "planet-text");
      text.setAttribute("text-anchor", "middle");
      text.textContent = p.name;
      svg.appendChild(text);
    });
  }

  // Convert input values to Julian Day UT (Universal Time) for calculations
  function getJulianDayFromInput(dob, tob) {
    // Parse date parts
    if (!dob || !tob) return null;
    const [yyyy, mm, dd] = dob.split("-").map(Number);
    const [hh, mi] = tob.split(":").map(Number);
    // Calculate Julian Day UT assuming input time is local time (approximate)
    // For accuracy, user localtime to UT conversion can be implemented
    return Astronomy.toJulianDay(yyyy, mm, dd, hh, mi);
  }

  // Calculate all planet longitudes approx for a given JD
  function calculatePlanets(jd) {
    return [
      { name: "Surya (Sun)", longitude: Astronomy.sunLongitude(jd) },
      { name: "Chandra (Moon)", longitude: Astronomy.moonLongitude(jd) },
      { name: "Budh (Mercury)", longitude: Astronomy.mercuryLongitude(jd) },
      { name: "Shukra (Venus)", longitude: Astronomy.venusLongitude(jd) },
      { name: "Mangal (Mars)", longitude: Astronomy.marsLongitude(jd) },
      { name: "Guru (Jupiter)", longitude: Astronomy.jupiterLongitude(jd) },
      { name: "Shani (Saturn)", longitude: Astronomy.saturnLongitude(jd) },
    ];
  }

  // Main form event listener
  const form = document.getElementById("kundliForm");
  const chartContainer = document.getElementById("chart-container");
  const analysis = document.getElementById("analysis");

  form.addEventListener("submit", e => {
    e.preventDefault();

    const dob = form.dob.value;
    const tob = form.tob.value;
    const lat = parseFloat(form.lat.value);
    const lng = parseFloat(form.lng.value);

    if (!dob || !tob || isNaN(lat) || isNaN(lng)) {
      alert(" कृपया सभी खाली स्थान सही से भरें। ");
      return;
    }

    // Julian Day UT from date/time inputs
    const jd = getJulianDayFromInput(dob, tob);

    // Planets array with approximate longitudes
    const planets = calculatePlanets(jd);

    // Calculate Ascendant approx longitude from Julian Day + latitude
    const ascendant = Astronomy.ascendantLongitude(jd, lat);

    // Draw chart with planets and ascendant info
    drawKundliChart(planets, ascendant, chartContainer);

    // Prepare textual analysis output
    let analysisText = `जन्म विवरण:\n  दिनांक: ${dob}\n  समय: ${tob}\n  अक्षांश: ${lat.toFixed(4)}\n  देशांतर: ${lng.toFixed(4)}\n\n`;
    analysisText += `उदय राशि (Ascendant): ${formatLongitude(ascendant)}\n\n`;
    analysisText += `ग्रहों की स्थिति (तरंगे):\n`;
    planets.forEach(p => {
      analysisText += `  ${p.name}: ${formatLongitude(p.longitude)}\n`;
    });

    analysis.innerText = analysisText;
  });
</script>
</body>
</html>
