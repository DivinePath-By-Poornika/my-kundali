<!DOCTYPE html>
<html lang="hi">
<head>
  <meta charset="utf-8" />
  <title>High-Accuracy Kundli (Vedic) - Browser Only</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <!-- Chart rendering deps -->
  <!-- Snap.svg for AstroChartJS -->
  <script src="https://cdn.jsdelivr.net/npm/snapsvg@0.5.1/dist/snap.svg-min.js"></script>
  <!-- AstroChartJS (Hindu charts) -->
  <script>
  // Minimal embedded AstroChartJS draw (North Indian) based on public usage examples
  // For full features, replace with official astrochart.js file.
  // Ref usage and options: erajasekar/astrochartjs
  // https://github.com/erajasekar/astrochartjs
  // Demo: http://erajasekar.com/astrochartjs-demo/
  // This simplified drawer expects a mapping {1:[...],2:[...],...,12:[...]} and draws a North Indian chart.
  class AstroChart {
    constructor(selector) {
      this.sel = selector;
    }
    draw(data, options) {
      const width = options.width || 600;
      const height = options.height || 600;
      const s = Snap(this.sel);
      s.clear();
      s.attr({ width, height });
      // Outer square
      const pad = 10;
      const size = Math.min(width, height) - 2
      * pad;
      const x0 = (width - size) / 2;
      const y0 = (height - size) / 2;
      const chart = s.rect(x0, y0, size, size).attr({ fill: "#faf7ef", stroke: "#333" });

      // North Indian diamonds (approximate layout)
      // House centers relative
      const cx = x0 + size / 2, cy = y0 + size / 2, r = size / 2;
      function pt(angle, rad) {
        return [cx + rad * Math.cos(angle), cy + rad * Math.sin(angle)];
      }
      const diag = [
        [x0, cy], [cx, y0], [x0 + size, cy], [cx, y0 + size]
      ];
      // Draw inner diamond
      s.polyline(
        diag.flat()
      ).attr({ fill: "none", stroke: "#555" });

      // Draw corner to midpoints to form houses
      const mids = [
        [x0 + size/2, y0], [x0 + size, y0 + size/2],
        [x0 + size/2, y0 + size], [x0, y0 + size/2]
      ];
      // Connect corners to opposite midpoints
      s.line(x0, y0, x0 + size, y0 + size).attr({ stroke: "#777" });
      s.line(x0 + size, y0, x0, y0 + size).attr({ stroke: "#777" });

      // Title
      const title = options.title || ["Rāśi", "", ""];
      s.text(width/2, y0 - 6, (title||"") + (title[12]?" • "+title[12]:"") + (title[13]?" • "+title[13]:""))
        .attr({ "text-anchor": "middle", "font-size": 14, "font-family": "sans-serif", fill:"#333" });

      // Simple placement for 12 houses labels
      // Predefined positions (rough NorthIndian layout)
      const housePos = [
        [cx, y0 + size*0.17],
        [x0 + size*0.78, y0 + size*0.22],
        [x0 + size*0.85, cy],
        [x0 + size*0.78, y0 + size*0.78],
        [cx, y0 + size*0.83],
        [x0 + size*0.22, y0 + size*0.78],
        [x0 + size*0.15, cy],
        [x0 + size*0.22, y0 + size*0.22],
        [cx, cy], // 9
        [cx + size*0.20, cy - size*0.20],
        [cx, cy - size*0.28],
        [cx - size*0.20, cy - size*0.20],
      ];

      const showNums = options.showHouseNumbers === true;
      const startFrom = Math.max(1, Math.min(12, options.startHouseNumbersFrom || 1));
      function houseNum(i) {
        // display number cycling from startFrom
        const n = ((i - 1 + (startFrom - 1)) % 12) + 1;
        return n;
      }

      for (let i = 1; i <= 12; i++) {
        const [tx, ty] = housePos[i-1];
        const label = data[i] && data[i].length ? data[i].join(" ") : "";
        let textLabel = label;
        if (showNums) textLabel = houseNum(i) + " " + textLabel;
        s.text(tx, ty, textLabel)
          .attr({ "text-anchor": "middle", "font-size": 12, "font-family": "Consolas, monospace", fill:"#222" });
      }
    }
  }
  </script>
  <style>
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif; margin: 20px; }
    .row { display: flex; gap: 16px; flex-wrap: wrap; }
    label { display:block; margin-top:8px; font-weight:600; }
    input, select, button { padding:8px; font-size:14px; }
    #chartWrap { max-width: 640px; }
    #analysis { max-width: 760px; white-space: pre-wrap; }
    .note { color:#555; font-size:12px; }
  </style>
</head>
<body>
  <h1>High-Accuracy Kundli (Vedic) – Browser Only</h1>
  <div class="row">
    <div>
      <label>Birth Date</label>
      <input id="dob" type="date" />
      <label>Birth Time (24h)</label>
      <input id="tob" type="time" step="60" />
      <label>City (auto lat/long)</label>
      <select id="city"></select>
      <div class="note">Cities list embedded; lat/long auto-selected. For geocoding APIs, integrate later.</div>
      <label>Time Zone Offset (hours vs UTC)</label>
      <input id="tz" type="number" step="0.5" value="5.5" />
      <label>House Start From (Ascendant sign index if known, else 1)</label>
      <input id="startHouse" type="number" min="1" max="12" value="1" />
      <div style="margin-top:10px;">
        <button id="btn">Generate Kundli</button>
      </div>
    </div>

    <div id="chartWrap">
      <svg id="chart" width="600" height="600"></svg>
    </div>
  </div>

  <h2>Detailed Analysis</h2>
  <div id="analysis">Enter birth details and click Generate Kundli.</div>
  <!-- Swiss Ephemeris WASM via jsDelivr CDN (browser) -->
  <!-- This package exposes a browser-ready WASM build for high-precision planetary positions -->
  <!-- Note: Loading from CDN requires a local HTTP server due to CORS if tested locally -->
  <script type="module">
    // High-accuracy ephemeris (Swiss Ephemeris WASM)
    // Using jsDelivr package for browser: swisseph-wasm
    // See: jsDelivr page mentions WASM module for pro-grade calculations
    // We dynamically import to ensure module loading.
    const seModuleUrl = 'https://cdn.jsdelivr.net/npm/swisseph-wasm/dist/index.js';

    // Minimal world cities subset (name,country,lat,lng). Replace with a larger dataset if needed.
    // For production, use a full JSON like lutangar/cities.json and populate the dropdown.
    // Here we include representative major cities for demo.
    const cities = [
      { name: "New Delhi", country: "India", lat: 28.6139, lng: 77.2090 },
      { name: "Mumbai", country: "India", lat: 19.0760, lng: 72.8777 },
      { name: "Kolkata", country: "India", lat: 22.5726, lng: 88.3639 },
      { name: "Chennai", country: "India", lat: 13.0827, lng: 80.2707 },
      { name: "Bengaluru", country: "India", lat: 12.9716, lng: 77.5946 },
      { name: "Hyderabad", country: "India", lat: 17.3850, lng: 78.4867 },
      { name: "Jaipur", country: "India", lat: 26.9124, lng: 75.7873 },
      { name: "Varanasi", country: "India", lat: 25.3176, lng: 82.9739 },
      { name: "London", country: "UK", lat: 51.5074, lng: -0.1278 },
      { name: "New York", country: "USA", lat: 40.7128, lng: -74.0060 }
    ];

    // Populate city dropdown
    const citySel = document.getElementById('city');
    cities.forEach((c, idx) => {
      const opt = document.createElement('option');
      opt.value = idx;
      opt.textContent = `${c.name}, ${c.country} (${c.lat.toFixed(4)}, ${c.lng.toFixed(4)})`;
      citySel.appendChild(opt);
    });
    // Utility: convert local date-time + tz to UTC Julian Day
    // Swiss Ephemeris prefers UT; we compute UT from local time + tz offset
    function toJulianDayUTC(dateStr, timeStr, tzHours) {
      // dateStr: "YYYY-MM-DD"; timeStr: "HH:MM"
      const [y, m, d] = dateStr.split('-').map(Number);
      const [H, M] = timeStr.split(':').map(Number);
      // Local time -> UTC
      const utcMillis = Date.UTC(y, m - 1, d, H - tzHours, M, 0);
      // Julian Day from JS date (millis)
      // JD (UTC) = (unixMillis / 86400000) + 2440587.5
      return utcMillis / 86400000 + 2440587.5;
    }

    // Compute geocentric ecliptic longitudes (Sun..Saturn) using Swiss Ephemeris WASM
    async function computePlanets(jdUT, lat, lng, se) {
      // Planets indexes (Swiss Ephemeris standard)
      const planets = [
        { name: "Sun", idx: 0 },
        { name: "Moon", idx: 1 },
        { name: "Mars", idx: 4 },
        { name: "Mercury", idx: 2 },
        { name: "Jupiter", idx: 5 },
        { name: "Venus", idx: 3 },
        { name: "Saturn", idx: 6 },
        // Rahu/Ketu (True Node/South Node)
        { name: "Rahu", idx: 11 }, // True Node
      ];
      const flags = se.SEFLG_SWIEPH | se.SEFLG_SPEED | se.SEFLG_MOSEPH; // use Swiss eph, with speed
      const results = {};
      for (const p of planets) {
        const out = se.swe_calc_ut(jdUT, p.idx, flags);
        if (out.rc !== se.ERR) {
          results[p.name] = { lon: out.x, lat: out.x[12], dist: out.x[13], speedLon: out.x[14] };
        } else {
          results[p.name] = null;
        }
      }
      // Ketu = Rahu + 180 mod 360
      if (results["Rahu"]) {
        const k = (results["Rahu"].lon + 180) % 360;
        results["Ketu"] = { lon: k, lat: results["Rahu"].lat, dist: results["Rahu"].dist, speedLon: results["Rahu"].speedLon };
      }
      return results;
    }
    // Determine Rāśi (sign) index from ecliptic longitude (0..360): Aries starts at 0
    function signIndexFromLongitude(lon) {
      return Math.floor(((lon % 360) + 360) % 360 / 30) + 1; // 1..12
    }

    // Very basic house allocation by sign-only scheme for demo
    // Production should compute Ascendant from local sidereal time and ecliptic obliquity.
    function houseMappingFromPlanets(planetLongitudes, ascSignIndex) {
      // Create empty 12 houses
      const houses = {};
      for (let i = 1; i <= 12; i++) houses[i] = [];
      // Put Asc label in house 1
      houses[12].push("Asc");
      // Map abbreviations
      const mapAbbr = {
        Sun: "Su", Moon: "Mo", Mars: "Ma", Mercury: "Me",
        Jupiter: "Ju", Venus: "Ve", Saturn: "Sa", Rahu: "Ra", Ketu: "Ke"
      };
      for (const [name, obj] of Object.entries(planetLongitudes)) {
        if (!obj) continue;
        const sidx = signIndexFromLongitude(obj.lon); // 1..12
        // relative house = ((planetSign - ascSign + 12) % 12) + 1
        const house = ((sidx - ascSignIndex + 12) % 12) + 1;
        houses[house].push(mapAbbr[name] || name);
      }
      return houses;
    }

    // Textual basic analysis demo
    function buildAnalysisText(city, tz, ascIdx, planetLongitudes) {
      const lines = [];
      lines.push(`Location: ${city.name}, ${city.country} (${city.lat.toFixed(4)}, ${city.lng.toFixed(4)})`);
      lines.push(`Time Zone offset: UTC${tz >= 0 ? "+" : ""}${tz}`);
      lines.push(`Ascendant starting sign index (1=Aries .. 12=Pisces): ${ascIdx}`);
      lines.push(`Planet Longitudes (°):`);
      for (const [k, v] of Object.entries(planetLongitudes)) {
        if (!v) continue;
        lines.push(`  ${k}: ${v.lon.toFixed(4)}° (sign ${signIndexFromLongitude(v.lon)})`);
      }
      lines.push(`Note: For production-grade houses and Ascendant, compute true Asc from latitude/longitude and sidereal time; this demo uses sign-based mapping for clarity.`);
      return lines.join("\n");
    }
    // Main
    let se = null;
    async function ensureSE() {
      if (se) return se;
      const mod = await import(seModuleUrl);
      // Initialize module
      se = await mod.default();
      // Set path for ephemeris; WASM build embeds data or fetches .se1 if needed
      // In many WASM builds, eph files are preloaded or not required at runtime for swe_calc_ut defaults.
      return se;
    }

    const btn = document.getElementById('btn');
    btn.addEventListener('click', async () => {
      const dob = document.getElementById('dob').value;
      const tob = document.getElementById('tob').value || "00:00";
      const tz = parseFloat(document.getElementById('tz').value || "5.5");
      const city = cities[parseInt(document.getElementById('city').value || "0", 10)];
      const startHouse = Math.max(1, Math.min(12, parseInt(document.getElementById('startHouse').value || "1", 10)));

      if (!dob) { alert("Please enter Birth Date"); return; }

      // Convert to Julian Day (UT)
      const jdUT = toJulianDayUTC(dob, tob, tz);

      // Load Swiss Ephemeris WASM and compute planets
      const se = await ensureSE();
      const planets = await computePlanets(jdUT, city.lat, city.lng, se);

      // For demo, Asc sign index comes from UI; in production compute true Asc from geo/time
      const ascIdx = startHouse;

      // House mapping and chart draw
      const houses = houseMappingFromPlanets(planets, ascIdx);
      const astroChart = new AstroChart("#chart");
      astroChart.draw(houses, {
        title: ["Rāśi", `${dob} ${tob} (UTC${tz>=0?"+":""}${tz})`, `${city.name}, ${city.country}`],
        width: 600,
        height: 600,
        showHouseNumbers: true,
        startHouseNumbersFrom: ascIdx
      });

      // Analysis text
      document.getElementById('analysis').textContent = buildAnalysisText(city, tz, ascIdx, planets);
    });

  </script>

  <p class="note">
    Tip: Open this file with a local web server (e.g., npx serve . or Python http.server) because browsers block WASM/CDN fetches via file://. Accuracy powered by Swiss Ephemeris WASM; chart drawn in-browser with SVG. Replace the sample cities array with a full cities JSON for broader auto-detection coverage.
  </p>
</body>
</html>
